var http = require("http");
const nodemon = require("nodemon");
const fs = require("fs");
const html = fs.readFileSync("page.html", "utf-8");

const server = http.createServer(function (req, res) {
  let path = req.url;
  if (path === "/" || path.toLocaleLowerCase() === "/home") {
    // res.end(html.replace('{{%welcome to home page%}}', "Home page"));
    res.end(html);
    
  } else if (path === "/about" || path.toLocaleLowerCase() === "/about") {
    res.end(html.replace('{{%text%}}', "about page"));
  } else if (path === "/contacts" || path.toLocaleLowerCase() === "/contacts") {
    res.end(html.replace('{{%text%}}', "contact page"));
  } else {
    res.end("<h1>404 Error Page not</h1>");
  }
  // res.end();
});

server.listen(3000);
console.log("server is running");



--------------------------------------
const { log } = require('console');
var http = require('http');

let server = http.createServer((req,res)=>{
    res.writeHead(200,{'content-type':'text/html'});
    res.write("hello world");
}
);
server.listen(8080);
console.log("server is running")




-----------------------------------------


const readline = require('readline');
const rl = readline.createInterface({
    input : process.stdin,
    output : process.stdout

});
rl.question("write your data here:",(name)=>{
    console.log("Your written data is :"+name);
    rl.close();
})
rl.on('close',()=>{
    console.log("interface is closed");
})



------------------------------------------------


const http = require('http');
const nodemon = require('nodemon');
const fs = require('fs');
const html = fs.readFileSync('res.html','utf-8');
const server = http.createServer(function(req,res){
    res.write("<h1>welcome to nodejs .......</h1>");
    res.end(html);
});
server.listen(3000,()=>{
  console.log("server is running");
  console.log("HELLO")
})

---------------------

sync - async
promise
difference b/w app.get & app.use
filesystem....
http methods and main methods we worked.... 
what is npm...how its used node js
what is the purpose require in node js
explain event driven architecture in node js



1)
In synchronous file operations, the code execution is blocked until the file operation is completed. This means that if you perform a file read or write operation, the entire JavaScript execution thread will be blocked until the file operation is finished.
The synchronous file system functions typically have names ending with 'Sync', such as readFileSync or writeFileSync


In asynchronous file operations, the code execution continues without waiting for the file operation to complete. Callback functions or Promises are used to handle the results of the file operations when they are finished.
Asynchronous file system functions don't block the event loop, allowing the application to remain responsive to other tasks. This is particularly important in scenarios where multiple I/O operations need to be performed concurrently.
Asynchronous functions do not have the 'Sync' suffix and often take a callback function or return a Promise.



2)Promises are a core concept in JavaScript, introduced to handle asynchronous operations in a more manageable and readable way. They provide a clean and more structured approach to dealing with asynchronous code compared to callbacks. Promises were officially introduced in ECMAScript 2015 (ES6) and have become a fundamental part of modern JavaScript development.


3)app.get:

app.get is a method used to define a route for handling HTTP GET requests.

It takes two arguments: the route path and a callback function that is executed when a request is made to that specific route using the HTTP GET method.

app.use:

app.use is a more general-purpose method used to mount middleware in Express.

Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the applicationâ€™s request-response cycle.

Middleware functions can perform various tasks, such as modifying the request or response objects, terminating the request-response cycle, or calling the next middleware function in the stack.



4)
HTTP (Hypertext Transfer Protocol) defines a set of methods that indicate the desired action to be performed for a given resource. These methods are the standard set of verbs used in the HTTP protocol. Here are some commonly used HTTP methods:

GET:

The GET method requests a representation of the specified resource. It should not have any side effects and is considered idempotent, meaning multiple identical requests should have the same effect as a single request.
POST:

The POST method is used to submit data to be processed to a specified resource. It can cause side effects, such as the creation of a new resource or the update of an existing one.
PUT:

The PUT method is used to update a resource or create a new resource if it doesn't exist at the specified URL.
DELETE:

The DELETE method is used to request the removal of a resource at a specific URL








5)npm stands for "Node Package Manager." It is a package manager for JavaScript, primarily used to manage and distribute Node.js modules (packages). Node.js is a JavaScript runtime that allows you to execute JavaScript code server-side. npm plays a crucial role in the Node.js ecosystem by providing a centralized repository for sharing and managing packages.

Here are some key points about npm and how it is used in Node.js:

Package Management:

npm is used to install, manage, and share packages (libraries or modules) for Node.js projects. These packages can include reusable pieces of code, tools, and frameworks created by the community.
Command-Line Interface:

npm is accessed through the command-line interface (CLI). Developers use commands like npm install, npm init, npm update, and others to interact with npm and manage project dependencies.
Package.json:

Each Node.js project typically includes a package.json file. This file contains metadata about the project and its dependencies. It also includes scripts, configuration settings, and other information. The package.json file is often created and maintained using npm commands or tools.
Installing Packages:

To install a package, you use the npm install command followed by the package name. For example:
Local vs. Global Installation:

Packages can be installed locally (in the project's node_modules directory) or globally (accessible across the system). Local installations are typical for project dependencies, while global installations are used for tools or utilities.


Package Scripts:

npm allows you to define custom scripts in the package.json file. These scripts can be executed using the npm run command. For example, you might have scripts for starting your server, running tests, or building your project.
Versioning:

npm uses semantic versioning (SemVer) to manage package versions. When you install a package without specifying a version, npm installs the latest version. You can also specify version ranges or use exact versions in your package.json file.

Publishing Packages:

Developers can publish their own packages to the npm registry, making them available for others to use. This encourages code sharing and collaboration within the Node.js community.
bash
Copy code
# Publish a package
npm publish
Dependency Management:

npm automatically manages dependencies for your project. When you install a package, npm also installs its dependencies, creating a dependency tree. This makes it easy to share and distribute projects with consistent dependencies.
Security Audits:

npm includes tools for auditing your project's dependencies to identify and address security vulnerabilities. This helps ensure that your project is using secure and up-to-date packages.
In summary, npm is a powerful tool for managing Node.js packages, handling dependencies, and streamlining the development process. It has become an integral part of the Node.js ecosystem, enabling developers to build scalable and modular applications by leveraging a vast collection of open-source packages.



6)require function is used to include external modules or files into a program. It's a fundamental part of the CommonJS module system, which Node.js uses to organize and structure code into reusable and maintainable components.




